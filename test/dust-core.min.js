/*! Dust - Asynchronous Templating - v2.3.4
* http://linkedin.github.io/dustjs/
* Copyright (c) 2014 Aleksander Williams; Released under the MIT License */
!function(root){function Context(a,b,c,d){this.stack=a,this.global=b,this.blocks=c,this.templateName=d}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&"object"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=""}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function Tap(a,b){this.head=a,this.tail=b}var dust={},NONE="NONE",ERROR="ERROR",WARN="WARN",INFO="INFO",DEBUG="DEBUG",loggingLevels=[DEBUG,INFO,WARN,ERROR,NONE],EMPTY_FUNC=function(){},logger={},originalLog,loggerContext;dust.debugLevel=NONE,dust.silenceErrors=!1,root&&root.console&&root.console.log&&(loggerContext=root.console,originalLog=root.console.log),logger.log=loggerContext?function(){logger.log="function"==typeof originalLog?function(){originalLog.apply(loggerContext,arguments)}:function(){var a=Array.prototype.slice.apply(arguments).join(" ");originalLog(a)},logger.log.apply(this,arguments)}:function(){},dust.log=function(a,b){if(dust.isDebug&&dust.debugLevel===NONE&&(logger.log('[!!!DEPRECATION WARNING!!!]: dust.isDebug is deprecated.  Set dust.debugLevel instead to the level of logging you want ["debug","info","warn","error","none"]'),dust.debugLevel=INFO),b=b||INFO,dust.indexInArray(loggingLevels,b)>=dust.indexInArray(loggingLevels,dust.debugLevel)&&(dust.logQueue||(dust.logQueue=[]),dust.logQueue.push({message:a,type:b}),logger.log("[DUST "+b+"]: "+a)),!dust.silenceErrors&&b===ERROR)throw"string"==typeof a?new Error(a):a},dust.onError=function(a,b){if(logger.log("[!!!DEPRECATION WARNING!!!]: dust.onError will no longer return a chunk object."),dust.log(a.message||a,ERROR),dust.silenceErrors)return b;throw a},dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(dust.cache[a]=b)},dust.render=function(a,b,c){var d=new Stub(c).head;try{dust.load(a,d,Context.wrap(b,a)).end()}catch(e){dust.log(e,ERROR)}},dust.stream=function(a,b){var c=new Stream;return dust.nextTick(function(){try{dust.load(a,c.head,Context.wrap(b,a)).end()}catch(d){dust.log(d,ERROR)}}),c},dust.renderSource=function(a,b,c){return dust.compileFn(a)(b,c)},dust.compileFn=function(a,b){b=b||null;var c=dust.loadSource(dust.compile(a,b));return function(a,d){var e=d?new Stub(d):new Stream;return dust.nextTick(function(){"function"==typeof c?c(e.head,Context.wrap(a,b)).end():dust.log(new Error("Template ["+b+"] cannot be resolved to a Dust function"),ERROR)}),e}},dust.load=function(a,b,c){var d=dust.cache[a];return d?d(b,c):dust.onLoad?b.map(function(b){dust.onLoad(a,function(d,e){return d?b.setError(d):(dust.cache[a]||dust.loadSource(dust.compile(e,a)),void dust.cache[a](b,c).end())})}):b.setError(new Error("Template Not Found: "+a))},dust.loadSource=function(source,path){return eval(source)},dust.isArray=Array.isArray?Array.isArray:function(a){return"[object Array]"===Object.prototype.toString.call(a)},dust.indexInArray=function(a,b,c){if(c=+c||0,Array.prototype.indexOf)return a.indexOf(b,c);if(void 0===a||null===a)throw new TypeError('cannot call method "indexOf" of null');var d=a.length;for(1/0===Math.abs(c)&&(c=0),0>c&&(c+=d,0>c&&(c=0));d>c;c++)if(a[c]===b)return c;return-1},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return dust.isArray(a)&&!a.length?!0:0===a?!1:!a},dust.filter=function(a,b,c){if(c)for(var d=0,e=c.length;e>d;d++){var f=c[d];"s"===f?(b=null,dust.log("Using unescape filter on ["+a+"]",DEBUG)):"function"==typeof dust.filters[f]?a=dust.filters[f](a):dust.log("Invalid filter ["+f+"]",WARN)}return b&&(a=dust.filters[b](a)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return JSON?JSON.stringify(a):(dust.log("JSON is undefined.  JSON stringify has not been used on ["+a+"]",WARN),a)},jp:function(a){return JSON?JSON.parse(a):(dust.log("JSON is undefined.  JSON parse has not been used on ["+a+"]",WARN),a)}},dust.makeBase=function(a){return new Context(new Stack,a)},Context.wrap=function(a,b){return a instanceof Context?a:new Context(new Stack(a),{},null,b)},Context.prototype.get=function(a,b){return"string"==typeof a&&("."===a[0]&&(b=!0,a=a.substr(1)),a=a.split(".")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g=this.stack,h=1;if(dust.log("Searching for reference [{"+b.join(".")+"}] in template ["+this.getTemplateName()+"]",DEBUG),d=b[0],e=b.length,a&&0===e)f=g,g=g.head;else{if(a)g&&(g=g.head?g.head[d]:void 0);else{for(;g&&(!g.isObject||(f=g.head,c=g.head[d],void 0===c));)g=g.tail;g=void 0!==c?c:this.global?this.global[d]:void 0}for(;g&&e>h;)f=g,g=g[b[h]],h++}if("function"==typeof g){var i=function(){try{return g.apply(f,arguments)}catch(a){return dust.log(a,ERROR)}};return i.isFunction=!0,i}return void 0===g&&dust.log("Cannot find the value for reference [{"+b.join(".")+"}] in template ["+this.getTemplateName()+"]"),g},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return new Context(new Stack(a,this.stack,b,c),this.global,this.blocks,this.getTemplateName())},Context.prototype.rebase=function(a){return new Context(new Stack(a),this.global,this.blocks,this.getTemplateName())},Context.prototype.current=function(){return this.stack.head},Context.prototype.getBlock=function(a){if("function"==typeof a){var b=new Chunk;a=a(b,this).data.join("")}var c=this.blocks;if(!c)return void dust.log("No blocks for context[{"+a+"}] in template ["+this.getTemplateName()+"]",DEBUG);for(var d,e=c.length;e--;)if(d=c[e][a])return d},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,b,this.getTemplateName())):this},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log("Chunk error ["+a.error+"] thrown. Ceasing to render this template.",WARN),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(""),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit("error",a.error),dust.log("Chunk error ["+a.error+"] thrown. Ceasing to render this template.",WARN),void(this.flush=EMPTY_FUNC)):void 0;this.emit("data",a.data.join("")),a=a.next,this.head=a}this.emit("end")},Stream.prototype.emit=function(a,b){if(!this.events)return dust.log("No events to emit",INFO),!1;var c=this.events[a];if(!c)return dust.log("Event type ["+a+"] does not exist",WARN),!1;if("function"==typeof c)c(b);else if(dust.isArray(c))for(var d=c.slice(0),e=0,f=d.length;f>e;e++)d[e](b);else dust.log("Event Handler ["+c+"] is not of a type that is handled by emit",WARN)},Stream.prototype.on=function(a,b){return this.events||(this.events={}),this.events[a]?"function"==typeof this.events[a]?this.events[a]=[this.events[a],b]:this.events[a].push(b):(dust.log("Event type ["+a+"] does not exist. Using just the specified callback.",WARN),b?this.events[a]=b:dust.log("Callback for type ["+a+"] does not exist. Listener not registered.",WARN)),this},Stream.prototype.pipe=function(a){return this.on("data",function(b){try{a.write(b,"utf8")}catch(c){dust.log(c,ERROR)}}).on("end",function(){try{return a.end()}catch(b){dust.log(b,ERROR)}}).on("error",function(b){a.error(b)}),this},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);return this.next=c,this.flushable=!0,a(c),b},Chunk.prototype.tap=function(a){var b=this.taps;return this.taps=b?b.push(a):new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return"function"==typeof a&&(a.isFunction=!0,a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk)?a:dust.isEmpty(a)?this:this.write(dust.filter(a,c,d))},Chunk.prototype.section=function(a,b,c,d){if("function"==typeof a&&(a=a.apply(b.current(),[this,b,c,d]),a instanceof Chunk))return a;var e=c.block,f=c["else"];if(d&&(b=b.push(d)),dust.isArray(a)){if(e){var g=a.length,h=this;if(g>0){b.stack.head&&(b.stack.head.$len=g);for(var i=0;g>i;i++)b.stack.head&&(b.stack.head.$idx=i),h=e(h,b.push(a[i],i,g));return b.stack.head&&(b.stack.head.$idx=void 0,b.stack.head.$len=void 0),h}if(f)return f(this,b)}}else if(a===!0){if(e)return e(this,b)}else if(a||0===a){if(e)return e(this,b.push(a))}else if(f)return f(this,b);return dust.log("Not rendering section (#) block in template ["+b.getTemplateName()+"], because above key was not found",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c["else"];if(dust.isEmpty(a)){if(e)return e(this,b)}else if(d)return d(this,b);return dust.log("Not rendering exists (?) block in template ["+b.getTemplateName()+"], because above key was not found",DEBUG),this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c["else"];if(dust.isEmpty(a)){if(d)return d(this,b)}else if(e)return e(this,b);return dust.log("Not rendering not exists (^) block check in template ["+b.getTemplateName()+"], because above key was found",DEBUG),this},Chunk.prototype.block=function(a,b,c){var d=c.block;return a&&(d=a),d?d(this,b):this},Chunk.prototype.partial=function(a,b,c){var d;d=dust.makeBase(b.global),d.blocks=b.blocks,b.stack&&b.stack.tail&&(d.stack=b.stack.tail),c&&(d=d.push(c)),"string"==typeof a&&(d.templateName=a),d=d.push(b.stack.head);var e;return e="function"==typeof a?this.capture(a,d,function(a,b){d.templateName=d.templateName||a,dust.load(a,b,d).end()}):dust.load(a,this,d)},Chunk.prototype.helper=function(a,b,c,d){var e=this;try{return dust.helpers[a]?dust.helpers[a](e,b,c,d):(dust.log("Invalid helper ["+a+"]",WARN),e)}catch(f){return dust.log(f,ERROR),e}},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this},Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=new RegExp(/[&<>\"\']/),AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\"/g,SQUOT=/\'/g;dust.escapeHtml=function(a){return"string"==typeof a?HCHARS.test(a)?a.replace(AMP,"&amp;").replace(LT,"&lt;").replace(GT,"&gt;").replace(QUOT,"&quot;").replace(SQUOT,"&#39;"):a:a};var BS=/\\/g,FS=/\//g,CR=/\r/g,LS=/\u2028/g,PS=/\u2029/g,NL=/\n/g,LF=/\f/g,SQ=/'/g,DQ=/"/g,TB=/\t/g;dust.escapeJs=function(a){return"string"==typeof a?a.replace(BS,"\\\\").replace(FS,"\\/").replace(DQ,'\\"').replace(SQ,"\\'").replace(CR,"\\r").replace(LS,"\\u2028").replace(PS,"\\u2029").replace(NL,"\\n").replace(LF,"\\f").replace(TB,"\\t"):a},"object"==typeof exports?module.exports=dust:root.dust=dust}(this);;
/* Dust Helpers */
/* https://github.com/linkedin/dustjs-helpers */
!function ( f ){
  if ( typeof module != undefined && module.exports ) module.exports = f
  else f(dust.helpers, dust)
}(function ( helpers, dust ){

// Note: all error conditions are logged to console and failed silently

  /* make a safe version of console if it is not available
   * currently supporting:
   *   _console.log
   * */
  var _console = (typeof console !== 'undefined') ? console : {
    log: function (){
      /* a noop*/
    }
  };

  function isSelect( context ){
    var value = context.current();
    return typeof value === "object" && value.isSelect === true;
  }

// Utility method : toString() equivalent for functions
  function jsonFilter( key, value ){
    if ( typeof value === "function" ) {
      //to make sure all environments format functions the same way
      return value.toString()
        //remove all leading and trailing whitespace
        .replace(/(^\s+|\s+$)/mg, '')
        //remove new line characters
        .replace(/\n/mg, '')
        //replace , and 0 or more spaces with ", "
        .replace(/,\s*/mg, ', ')
        //insert space between ){
        .replace(/\)\{/mg, ') {')
        ;
    }
    return value;
  }

// Utility method: to invoke the given filter operation such as eq/gt etc
  function filter( chunk, context, bodies, params, filterOp ){
    params = params || {};
    var body = bodies.block,
      actualKey,
      expectedValue,
      filterOpType = params.filterOpType || '';
    // when @eq, @lt etc are used as standalone helpers, key is required and hence check for defined
    if ( typeof params.key !== "undefined" ) {
      actualKey = dust.helpers.tap(params.key, chunk, context);
    }
    else if ( isSelect(context) ) {
      actualKey = context.current().selectKey;
      //  supports only one of the blocks in the select to be selected
      if ( context.current().isResolved ) {
        filterOp = function (){ return false; };
      }
    }
    else {
      _console.log("No key specified for filter in:" + filterOpType + " helper ");
      return chunk;
    }
    expectedValue = dust.helpers.tap(params.value, chunk, context);
    // coerce both the actualKey and expectedValue to the same type for equality and non-equality compares
    if ( filterOp(coerce(expectedValue, params.type, context), coerce(actualKey, params.type, context)) ) {
      if ( isSelect(context) ) {
        context.current().isResolved = true;
      }
      // we want helpers without bodies to fail gracefully so check it first
      if ( body ) {
        return chunk.render(body, context);
      }
      else {
        _console.log("Missing body block in the " + filterOpType + " helper ");
        return chunk;
      }
    }
    else if ( bodies['else'] ) {
      return chunk.render(bodies['else'], context);
    }
    return chunk;
  }

  function coerce( value, type, context ){
    if ( value ) {
      switch ( type || typeof(value) ) {
        case 'number':
          return +value;
        case 'string':
          return String(value);
        case 'boolean':
        {
          value = (value === 'false' ? false : value);
          return Boolean(value);
        }
        case 'date':
          return new Date(value);
        case 'context':
          return context.get(value);
      }
    }

    return value;
  }

  // Utility helping to resolve dust references in the given chunk
  // uses the Chunk.render method to resolve value
  /*
   Reference resolution rules:
   if value exists in JSON:
   "" or '' will evaluate to false, boolean false, null, or undefined will evaluate to false,
   numeric 0 evaluates to true, so does, string "0", string "null", string "undefined" and string "false".
   Also note that empty array -> [] is evaluated to false and empty object -> {} and non-empty object are evaluated to true
   The type of the return value is string ( since we concatenate to support interpolated references

   if value does not exist in JSON and the input is a single reference: {x}
   dust render emits empty string, and we then return false

   if values does not exist in JSON and the input is interpolated references : {x} < {y}
   dust render emits <  and we return the partial output

   */
  helpers.tap = function ( input, chunk, context ){
    // return given input if there is no dust reference to resolve
    // dust compiles a string/reference such as {foo} to a function
    if ( typeof input !== "function" ) {
      return input;
    }

    var dustBodyOutput = '',
      returnValue;

    //use chunk render to evaluate output. For simple functions result will be returned from render call,
    //for dust body functions result will be output via callback function
    returnValue = chunk.tap(function ( data ){
      dustBodyOutput += data;
      return '';
    }).render(input, context);

    chunk.untap();

    //assume it's a simple function call if return result is not a chunk
    if ( returnValue.constructor !== chunk.constructor ) {
      //use returnValue as a result of tap
      return returnValue;
    } else if ( dustBodyOutput === '' ) {
      return false;
    } else {
      return dustBodyOutput;
    }
  }

  helpers.sep = function ( chunk, context, bodies ){
    var body = bodies.block;
    if ( context.stack.index === context.stack.of - 1 ) {
      return chunk;
    }
    if ( body ) {
      return bodies.block(chunk, context);
    }
    else {
      return chunk;
    }
  }

  helpers.idx = function ( chunk, context, bodies ){
    var body = bodies.block;
    if ( body ) {
      return bodies.block(chunk, context.push(context.stack.index));
    }
    else {
      return chunk;
    }
  }

  /**
   * contextDump helper
   * @param key specifies how much to dump.
   * "current" dumps current context. "full" dumps the full context stack.
   * @param to specifies where to write dump output.
   * Values can be "console" or "output". Default is output.
   */
  helpers.contextDump = function ( chunk, context, bodies, params ){
    var p = params || {},
      to = p.to || 'output',
      key = p.key || 'current',
      dump;
    to = dust.helpers.tap(to, chunk, context);
    key = dust.helpers.tap(key, chunk, context);
    if ( key === 'full' ) {
      dump = JSON.stringify(context.stack, jsonFilter, 2);
    }
    else {
      dump = JSON.stringify(context.stack.head, jsonFilter, 2);
    }
    if ( to === 'console' ) {
      _console.log(dump);
      return chunk;
    }
    else {
      return chunk.write(dump);
    }
  }
  /**
   if helper for complex evaluation complex logic expressions.
   Note : #1 if helper fails gracefully when there is no body block nor else block
   #2 Undefined values and false values in the JSON need to be handled specially with .length check
   for e.g @if cond=" '{a}'.length && '{b}'.length" is advised when there are chances of the a and b been
   undefined or false in the context
   #3 Use only when the default ? and ^ dust operators and the select fall short in addressing the given logic,
   since eval executes in the global scope
   #4 All dust references are default escaped as they are resolved, hence eval will block malicious scripts in the context
   Be mindful of evaluating a expression that is passed through the unescape filter -> |s
   @param cond, either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. cond="2>3"
   a dust reference is also enclosed in double quotes, e.g. cond="'{val}'' > 3"
   cond argument should evaluate to a valid javascript expression
   **/

  helpers["if"] = function ( chunk, context, bodies, params ){
    var body = bodies.block,
      skip = bodies['else'];
    if ( params && params.cond ) {
      var cond = params.cond;
      cond = dust.helpers.tap(cond, chunk, context);
      // eval expressions with given dust references
      if ( eval(cond) ) {
        if ( body ) {
          return chunk.render(bodies.block, context);
        }
        else {
          _console.log("Missing body block in the if helper!");
          return chunk;
        }
      }
      if ( skip ) {
        return chunk.render(bodies['else'], context);
      }
    }
    // no condition
    else {
      _console.log("No condition given in the if helper!");
    }
    return chunk;
  }

  /**
   * math helper
   * @param key is the value to perform math against
   * @param method is the math method,  is a valid string supported by math helper like mod, add, subtract
   * @param operand is the second value needed for operations like mod, add, subtract, etc.
   * @param round is a flag to assure that an integer is returned
   */
  helpers.math = function ( chunk, context, bodies, params ){
    //key and method are required for further processing
    if ( params && typeof params.key !== "undefined" && params.method ) {
      var key = params.key,
        method = params.method,
      // operand can be null for "abs", ceil and floor
        operand = params.operand,
        round = params.round,
        mathOut = null,
        operError = function (){
          _console.log("operand is required for this math method");
          return null;
        };
      key = dust.helpers.tap(key, chunk, context);
      operand = dust.helpers.tap(operand, chunk, context);
      //  TODO: handle  and tests for negatives and floats in all math operations
      switch ( method ) {
        case "mod":
          if ( operand === 0 || operand === -0 ) {
            _console.log("operand for divide operation is 0/-0: expect Nan!");
          }
          mathOut = parseFloat(key) % parseFloat(operand);
          break;
        case "add":
          mathOut = parseFloat(key) + parseFloat(operand);
          break;
        case "subtract":
          mathOut = parseFloat(key) - parseFloat(operand);
          break;
        case "multiply":
          mathOut = parseFloat(key) * parseFloat(operand);
          break;
        case "divide":
          if ( operand === 0 || operand === -0 ) {
            _console.log("operand for divide operation is 0/-0: expect Nan/Infinity!");
          }
          mathOut = parseFloat(key) / parseFloat(operand);
          break;
        case "ceil":
          mathOut = Math.ceil(parseFloat(key));
          break;
        case "floor":
          mathOut = Math.floor(parseFloat(key));
          break;
        case "round":
          mathOut = Math.round(parseFloat(key));
          break;
        case "abs":
          mathOut = Math.abs(parseFloat(key));
          break;
        default:
          _console.log("method passed is not supported");
      }

      if ( mathOut !== null ) {
        if ( round ) {
          mathOut = Math.round(mathOut);
        }
        if ( bodies && bodies.block ) {
          // with bodies act like the select helper with mathOut as the key
          // like the select helper bodies['else'] is meaningless and is ignored
          return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: mathOut }));
        } else {
          // self closing math helper will return the calculated output
          return chunk.write(mathOut);
        }
      } else {
        return chunk;
      }
    }
    // no key parameter and no method
    else {
      _console.log("Key is a required parameter for math helper along with method/operand!");
    }
    return chunk;
  }
  /**
   select helper works with one of the eq/ne/gt/gte/lt/lte/default providing the functionality
   of branching conditions
   @param key,  ( required ) either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   **/
  helpers.select = function ( chunk, context, bodies, params ){
    var body = bodies.block;
    // key is required for processing, hence check for defined
    if ( params && typeof params.key !== "undefined" ) {
      // returns given input as output, if the input is not a dust reference, else does a context lookup
      var key = dust.helpers.tap(params.key, chunk, context);
      // bodies['else'] is meaningless and is ignored
      if ( body ) {
        return chunk.render(bodies.block, context.push({ isSelect: true, isResolved: false, selectKey: key }));
      }
      else {
        _console.log("Missing body block in the select helper ");
        return chunk;
      }
    }
    // no key
    else {
      _console.log("No key given in the select helper!");
    }
    return chunk;
  }

  /**
   eq helper compares the given key is same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.eq = function ( chunk, context, bodies, params ){
    if ( params ) {
      params.filterOpType = "eq";
    }
    return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual === expected; });
  }

  /**
   ne helper compares the given key is not the same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.ne = function ( chunk, context, bodies, params ){
    if ( params ) {
      params.filterOpType = "ne";
      return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual !== expected; });
    }
    return chunk;
  }

  /**
   lt helper compares the given key is less than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.lt = function ( chunk, context, bodies, params ){
    if ( params ) {
      params.filterOpType = "lt";
      return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual < expected; });
    }
  }

  /**
   lte helper compares the given key is less or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.lte = function ( chunk, context, bodies, params ){
    if ( params ) {
      params.filterOpType = "lte";
      return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual <= expected; });
    }
    return chunk;
  }

  /**
   gt helper compares the given key is greater than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.gt = function ( chunk, context, bodies, params ){
    // if no params do no go further
    if ( params ) {
      params.filterOpType = "gt";
      return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual > expected; });
    }
    return chunk;
  }

  /**
   gte helper, compares the given key is greater than or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
   either a string literal value or a dust reference
   a string literal value, is enclosed in double quotes, e.g. key="foo"
   a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  helpers.gte = function ( chunk, context, bodies, params ){
    if ( params ) {
      params.filterOpType = "gte";
      return filter(chunk, context, bodies, params, function ( expected, actual ){ return actual >= expected; });
    }
    return chunk;
  }

  // to be used in conjunction with the select helper
  // TODO: fix the helper to do nothing when used standalone
  helpers["default"] = function ( chunk, context, bodies, params ){
    // does not require any params
    if ( params ) {
      params.filterOpType = "default";
    }
    return filter(chunk, context, bodies, params, function ( expected, actual ){ return true; });
  }

  /**
   * size helper prints the size of the given key
   * Note : size helper is self closing and does not support bodies
   * @param key, the element whose size is returned
   */
  helpers.size = function ( chunk, context, bodies, params ){
    var key, value = 0, nr, k;
    params = params || {};
    key = params.key;
    if ( !key || key === true ) { //undefined, null, "", 0
      value = 0;
    }
    else if ( dust.isArray(key) ) { //array
      value = key.length;
    }
    else if ( !isNaN(parseFloat(key)) && isFinite(key) ) { //numeric values
      value = key;
    }
    else if ( typeof key === "object" ) { //object test
      //objects, null and array all have typeof ojbect...
      //null and array are already tested so typeof is sufficient http://jsperf.com/isobject-tests
      nr = 0;
      for ( k in key ) {
        if ( Object.hasOwnProperty.call(key, k) ) {
          nr++;
        }
      }
      value = nr;
    } else {
      value = (key + '').length; //any other value (strings etc.)
    }
    return chunk.write(value);
  }

})
/* Dustin Helpers */
!function ( f ){
  if( typeof module != undefined  && module.exports ) module.exports = f
  else f(dust, dust.helpers)
}(function ( helpers ){
  /**
   *
   * Params:
   *
   * $key: a variable name for the key. defaults to `$key`
   * $value: a variable for the value. defaults to `$value`
   * $in: the object to iterate over if not provided `context.current()` will be used
   *
   * params are prefixed with a `$` so it's less likely they clash with context members
   *
   * @example
   *
   * Context
   *
   * "ooo": {
   *  "a": {
   *    "1": "1"
   *  },
   *  "b": {
   *    "2": "2"
   *  }
   * }
   *
   * Template
   *
   * {@for var="asd" value="qwe" $in=ooo}
   *   {asd}
   *   {@for:qwe}
   *     {$key} - {$value} {~n}
   *   {/for}
   * {/for}
   *
   * Output
   *
   * a1 - 1
   * b2 - 2
   * */
  helpers["for"] = function ( chunk, context, bodies, params ){
    params = params || {}
    var obj = params["$in"] || context.current()
      , keyVar = params["$key"] || "$key"
      , valueVar = params["$value"] || "$value"
      , body = bodies.block
      , key
      , value
      , contextObj

    if ( obj && body ) {
      for ( key in obj ) {
        if ( obj.hasOwnProperty(key) ) {
          value = obj[key]
          contextObj = {}
          contextObj[keyVar] = key
          contextObj[valueVar] = value
          contextObj.type = typeof value
          chunk = body(chunk, context.push(contextObj))
        }
      }
    }

    return chunk
  }
});
!function ( f ){
  if ( typeof module != undefined && module.exports ) module.exports = f
  else f(dust, dust.helpers)
}(function ( helpers ){
  helpers.macro = function ( chunk, context, bodies, params ){
    var body = bodies.block
      , partial = params.partial
      , template

    delete params.partial
    context = context.push(params)

    if ( partial ) {
      template = dust.cache[partial]
      if ( template ) {
        return template(chunk, context)
      }
      else {
        dust.onLoad(partial, function ( err, template ){
          template = dust.compile(template, partial)
          dust.loadSource(template)
          template = dust.cache[partial]
          template(chunk, context)
        })
        return chunk
      }
    }
    return body ? body(chunk, context) : chunk
  }
});
!function ( f ){
  if ( typeof module != undefined && module.exports ) module.exports = f
  else f(dust, dust.helpers)
}(function ( helpers ){

  /**
   * This simply sets the context to the head of the stack.
   * It helps cutting down on typing accessors.
   *
   * @example
   *
   * "someObject": {
   *  "a": "hello",
   *  "b": "hi"
   * }
   * {@with:someObject}
   *   {a}{~n}
   *   {b}
   * {/with}
   *
   * Output
   * hello
   * hi
   *
   * */
  helpers["with"] = function ( chunk, context, bodies, params ){
    var body = bodies.block
    if ( body ) {
      chunk = body(chunk, context.push(context.current()))
    }
    return chunk
  }
})
/* User Helpers */

/* Dustin functions */
dust.onLoad = function ( template, done ){
  var script = document.createElement("script")
  script.src = template[0] == "/" || /^https?:/.test(template)
    ? template
    : ("/view/"+"/"+template+".js").replace(/\/+/g, "/")
  script.async = false
  document.head.appendChild(script)
  var ok
    , error = null
  script.onload = function( e ){
    ok || done(error)
    ok = true
    script.onload = null
    script.onerror = null
  }
  script.onerror = function( e ){
    ok || done(error = e)
    ok = true
    script.onload = null
    script.onerror = null
  }
};
dust.renderElement = function( template, context, done ){
  dust.render(template, context, function( err, rendered ){
    if( err ) done(err)
    else{
      var div = document.createElement("div")
      div.innerHTML = rendered
      var fragment = document.createDocumentFragment()
      while ( div.childNodes.length ) {
        fragment.appendChild(div.childNodes[0])
      }
      done(null, fragment)
      div = fragment = null
    }
  })
}
